// Code generated by mockery v2.51.0. DO NOT EDIT.

package observability

import (
	context "context"

	gin "github.com/gin-gonic/gin"
	metric "go.opentelemetry.io/otel/metric"

	mock "github.com/stretchr/testify/mock"

	observability "github.com/xBlaz3kx/DevX/observability"

	otelzap "github.com/GLCharge/otelzap"

	time "time"

	trace "go.opentelemetry.io/otel/trace"

	zapcore "go.uber.org/zap/zapcore"
)

// MockObservability is an autogenerated mock type for the Observability type
type MockObservability struct {
	mock.Mock
}

type MockObservability_Expecter struct {
	mock *mock.Mock
}

func (_m *MockObservability) EXPECT() *MockObservability_Expecter {
	return &MockObservability_Expecter{mock: &_m.Mock}
}

// AreMetricsEnabled provides a mock function with no fields
func (_m *MockObservability) AreMetricsEnabled() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AreMetricsEnabled")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockObservability_AreMetricsEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AreMetricsEnabled'
type MockObservability_AreMetricsEnabled_Call struct {
	*mock.Call
}

// AreMetricsEnabled is a helper method to define mock.On call
func (_e *MockObservability_Expecter) AreMetricsEnabled() *MockObservability_AreMetricsEnabled_Call {
	return &MockObservability_AreMetricsEnabled_Call{Call: _e.mock.On("AreMetricsEnabled")}
}

func (_c *MockObservability_AreMetricsEnabled_Call) Run(run func()) *MockObservability_AreMetricsEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockObservability_AreMetricsEnabled_Call) Return(_a0 bool) *MockObservability_AreMetricsEnabled_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockObservability_AreMetricsEnabled_Call) RunAndReturn(run func() bool) *MockObservability_AreMetricsEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// IsProfilingEnabled provides a mock function with no fields
func (_m *MockObservability) IsProfilingEnabled() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsProfilingEnabled")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockObservability_IsProfilingEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsProfilingEnabled'
type MockObservability_IsProfilingEnabled_Call struct {
	*mock.Call
}

// IsProfilingEnabled is a helper method to define mock.On call
func (_e *MockObservability_Expecter) IsProfilingEnabled() *MockObservability_IsProfilingEnabled_Call {
	return &MockObservability_IsProfilingEnabled_Call{Call: _e.mock.On("IsProfilingEnabled")}
}

func (_c *MockObservability_IsProfilingEnabled_Call) Run(run func()) *MockObservability_IsProfilingEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockObservability_IsProfilingEnabled_Call) Return(_a0 bool) *MockObservability_IsProfilingEnabled_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockObservability_IsProfilingEnabled_Call) RunAndReturn(run func() bool) *MockObservability_IsProfilingEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// IsTracingEnabled provides a mock function with no fields
func (_m *MockObservability) IsTracingEnabled() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsTracingEnabled")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockObservability_IsTracingEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsTracingEnabled'
type MockObservability_IsTracingEnabled_Call struct {
	*mock.Call
}

// IsTracingEnabled is a helper method to define mock.On call
func (_e *MockObservability_Expecter) IsTracingEnabled() *MockObservability_IsTracingEnabled_Call {
	return &MockObservability_IsTracingEnabled_Call{Call: _e.mock.On("IsTracingEnabled")}
}

func (_c *MockObservability_IsTracingEnabled_Call) Run(run func()) *MockObservability_IsTracingEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockObservability_IsTracingEnabled_Call) Return(_a0 bool) *MockObservability_IsTracingEnabled_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockObservability_IsTracingEnabled_Call) RunAndReturn(run func() bool) *MockObservability_IsTracingEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// Log provides a mock function with no fields
func (_m *MockObservability) Log() *otelzap.Logger {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Log")
	}

	var r0 *otelzap.Logger
	if rf, ok := ret.Get(0).(func() *otelzap.Logger); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*otelzap.Logger)
		}
	}

	return r0
}

// MockObservability_Log_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Log'
type MockObservability_Log_Call struct {
	*mock.Call
}

// Log is a helper method to define mock.On call
func (_e *MockObservability_Expecter) Log() *MockObservability_Log_Call {
	return &MockObservability_Log_Call{Call: _e.mock.On("Log")}
}

func (_c *MockObservability_Log_Call) Run(run func()) *MockObservability_Log_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockObservability_Log_Call) Return(_a0 *otelzap.Logger) *MockObservability_Log_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockObservability_Log_Call) RunAndReturn(run func() *otelzap.Logger) *MockObservability_Log_Call {
	_c.Call.Return(run)
	return _c
}

// LogSpan provides a mock function with given fields: ctx, spanName, fields
func (_m *MockObservability) LogSpan(ctx context.Context, spanName string, fields ...zapcore.Field) (context.Context, func(), otelzap.LoggerWithCtx) {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, spanName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LogSpan")
	}

	var r0 context.Context
	var r1 func()
	var r2 otelzap.LoggerWithCtx
	if rf, ok := ret.Get(0).(func(context.Context, string, ...zapcore.Field) (context.Context, func(), otelzap.LoggerWithCtx)); ok {
		return rf(ctx, spanName, fields...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...zapcore.Field) context.Context); ok {
		r0 = rf(ctx, spanName, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...zapcore.Field) func()); ok {
		r1 = rf(ctx, spanName, fields...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func())
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ...zapcore.Field) otelzap.LoggerWithCtx); ok {
		r2 = rf(ctx, spanName, fields...)
	} else {
		r2 = ret.Get(2).(otelzap.LoggerWithCtx)
	}

	return r0, r1, r2
}

// MockObservability_LogSpan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogSpan'
type MockObservability_LogSpan_Call struct {
	*mock.Call
}

// LogSpan is a helper method to define mock.On call
//   - ctx context.Context
//   - spanName string
//   - fields ...zapcore.Field
func (_e *MockObservability_Expecter) LogSpan(ctx interface{}, spanName interface{}, fields ...interface{}) *MockObservability_LogSpan_Call {
	return &MockObservability_LogSpan_Call{Call: _e.mock.On("LogSpan",
		append([]interface{}{ctx, spanName}, fields...)...)}
}

func (_c *MockObservability_LogSpan_Call) Run(run func(ctx context.Context, spanName string, fields ...zapcore.Field)) *MockObservability_LogSpan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]zapcore.Field, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(zapcore.Field)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockObservability_LogSpan_Call) Return(_a0 context.Context, _a1 func(), _a2 otelzap.LoggerWithCtx) *MockObservability_LogSpan_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockObservability_LogSpan_Call) RunAndReturn(run func(context.Context, string, ...zapcore.Field) (context.Context, func(), otelzap.LoggerWithCtx)) *MockObservability_LogSpan_Call {
	_c.Call.Return(run)
	return _c
}

// LogSpanWithTimeout provides a mock function with given fields: ctx, spanName, timeout, fields
func (_m *MockObservability) LogSpanWithTimeout(ctx context.Context, spanName string, timeout time.Duration, fields ...zapcore.Field) (context.Context, func(), otelzap.LoggerWithCtx) {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, spanName, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LogSpanWithTimeout")
	}

	var r0 context.Context
	var r1 func()
	var r2 otelzap.LoggerWithCtx
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, ...zapcore.Field) (context.Context, func(), otelzap.LoggerWithCtx)); ok {
		return rf(ctx, spanName, timeout, fields...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, ...zapcore.Field) context.Context); ok {
		r0 = rf(ctx, spanName, timeout, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, time.Duration, ...zapcore.Field) func()); ok {
		r1 = rf(ctx, spanName, timeout, fields...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func())
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, time.Duration, ...zapcore.Field) otelzap.LoggerWithCtx); ok {
		r2 = rf(ctx, spanName, timeout, fields...)
	} else {
		r2 = ret.Get(2).(otelzap.LoggerWithCtx)
	}

	return r0, r1, r2
}

// MockObservability_LogSpanWithTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogSpanWithTimeout'
type MockObservability_LogSpanWithTimeout_Call struct {
	*mock.Call
}

// LogSpanWithTimeout is a helper method to define mock.On call
//   - ctx context.Context
//   - spanName string
//   - timeout time.Duration
//   - fields ...zapcore.Field
func (_e *MockObservability_Expecter) LogSpanWithTimeout(ctx interface{}, spanName interface{}, timeout interface{}, fields ...interface{}) *MockObservability_LogSpanWithTimeout_Call {
	return &MockObservability_LogSpanWithTimeout_Call{Call: _e.mock.On("LogSpanWithTimeout",
		append([]interface{}{ctx, spanName, timeout}, fields...)...)}
}

func (_c *MockObservability_LogSpanWithTimeout_Call) Run(run func(ctx context.Context, spanName string, timeout time.Duration, fields ...zapcore.Field)) *MockObservability_LogSpanWithTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]zapcore.Field, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(zapcore.Field)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockObservability_LogSpanWithTimeout_Call) Return(_a0 context.Context, _a1 func(), _a2 otelzap.LoggerWithCtx) *MockObservability_LogSpanWithTimeout_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockObservability_LogSpanWithTimeout_Call) RunAndReturn(run func(context.Context, string, time.Duration, ...zapcore.Field) (context.Context, func(), otelzap.LoggerWithCtx)) *MockObservability_LogSpanWithTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// Meter provides a mock function with given fields: name, opts
func (_m *MockObservability) Meter(name string, opts ...metric.MeterOption) metric.Meter {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Meter")
	}

	var r0 metric.Meter
	if rf, ok := ret.Get(0).(func(string, ...metric.MeterOption) metric.Meter); ok {
		r0 = rf(name, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metric.Meter)
		}
	}

	return r0
}

// MockObservability_Meter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Meter'
type MockObservability_Meter_Call struct {
	*mock.Call
}

// Meter is a helper method to define mock.On call
//   - name string
//   - opts ...metric.MeterOption
func (_e *MockObservability_Expecter) Meter(name interface{}, opts ...interface{}) *MockObservability_Meter_Call {
	return &MockObservability_Meter_Call{Call: _e.mock.On("Meter",
		append([]interface{}{name}, opts...)...)}
}

func (_c *MockObservability_Meter_Call) Run(run func(name string, opts ...metric.MeterOption)) *MockObservability_Meter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]metric.MeterOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(metric.MeterOption)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockObservability_Meter_Call) Return(_a0 metric.Meter) *MockObservability_Meter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockObservability_Meter_Call) RunAndReturn(run func(string, ...metric.MeterOption) metric.Meter) *MockObservability_Meter_Call {
	_c.Call.Return(run)
	return _c
}

// Metrics provides a mock function with no fields
func (_m *MockObservability) Metrics() *observability.Metrics {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Metrics")
	}

	var r0 *observability.Metrics
	if rf, ok := ret.Get(0).(func() *observability.Metrics); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*observability.Metrics)
		}
	}

	return r0
}

// MockObservability_Metrics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Metrics'
type MockObservability_Metrics_Call struct {
	*mock.Call
}

// Metrics is a helper method to define mock.On call
func (_e *MockObservability_Expecter) Metrics() *MockObservability_Metrics_Call {
	return &MockObservability_Metrics_Call{Call: _e.mock.On("Metrics")}
}

func (_c *MockObservability_Metrics_Call) Run(run func()) *MockObservability_Metrics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockObservability_Metrics_Call) Return(_a0 *observability.Metrics) *MockObservability_Metrics_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockObservability_Metrics_Call) RunAndReturn(run func() *observability.Metrics) *MockObservability_Metrics_Call {
	_c.Call.Return(run)
	return _c
}

// SetupGinMiddleware provides a mock function with given fields: router, opts
func (_m *MockObservability) SetupGinMiddleware(router *gin.Engine, opts ...observability.MetricMiddlewareOpt) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, router)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockObservability_SetupGinMiddleware_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetupGinMiddleware'
type MockObservability_SetupGinMiddleware_Call struct {
	*mock.Call
}

// SetupGinMiddleware is a helper method to define mock.On call
//   - router *gin.Engine
//   - opts ...observability.MetricMiddlewareOpt
func (_e *MockObservability_Expecter) SetupGinMiddleware(router interface{}, opts ...interface{}) *MockObservability_SetupGinMiddleware_Call {
	return &MockObservability_SetupGinMiddleware_Call{Call: _e.mock.On("SetupGinMiddleware",
		append([]interface{}{router}, opts...)...)}
}

func (_c *MockObservability_SetupGinMiddleware_Call) Run(run func(router *gin.Engine, opts ...observability.MetricMiddlewareOpt)) *MockObservability_SetupGinMiddleware_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]observability.MetricMiddlewareOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(observability.MetricMiddlewareOpt)
			}
		}
		run(args[0].(*gin.Engine), variadicArgs...)
	})
	return _c
}

func (_c *MockObservability_SetupGinMiddleware_Call) Return() *MockObservability_SetupGinMiddleware_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockObservability_SetupGinMiddleware_Call) RunAndReturn(run func(*gin.Engine, ...observability.MetricMiddlewareOpt)) *MockObservability_SetupGinMiddleware_Call {
	_c.Run(run)
	return _c
}

// Shutdown provides a mock function with given fields: ctx
func (_m *MockObservability) Shutdown(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockObservability_Shutdown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shutdown'
type MockObservability_Shutdown_Call struct {
	*mock.Call
}

// Shutdown is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockObservability_Expecter) Shutdown(ctx interface{}) *MockObservability_Shutdown_Call {
	return &MockObservability_Shutdown_Call{Call: _e.mock.On("Shutdown", ctx)}
}

func (_c *MockObservability_Shutdown_Call) Run(run func(ctx context.Context)) *MockObservability_Shutdown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockObservability_Shutdown_Call) Return(_a0 error) *MockObservability_Shutdown_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockObservability_Shutdown_Call) RunAndReturn(run func(context.Context) error) *MockObservability_Shutdown_Call {
	_c.Call.Return(run)
	return _c
}

// Span provides a mock function with given fields: ctx, spanName, fields
func (_m *MockObservability) Span(ctx context.Context, spanName string, fields ...zapcore.Field) (context.Context, func()) {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, spanName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Span")
	}

	var r0 context.Context
	var r1 func()
	if rf, ok := ret.Get(0).(func(context.Context, string, ...zapcore.Field) (context.Context, func())); ok {
		return rf(ctx, spanName, fields...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...zapcore.Field) context.Context); ok {
		r0 = rf(ctx, spanName, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...zapcore.Field) func()); ok {
		r1 = rf(ctx, spanName, fields...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func())
		}
	}

	return r0, r1
}

// MockObservability_Span_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Span'
type MockObservability_Span_Call struct {
	*mock.Call
}

// Span is a helper method to define mock.On call
//   - ctx context.Context
//   - spanName string
//   - fields ...zapcore.Field
func (_e *MockObservability_Expecter) Span(ctx interface{}, spanName interface{}, fields ...interface{}) *MockObservability_Span_Call {
	return &MockObservability_Span_Call{Call: _e.mock.On("Span",
		append([]interface{}{ctx, spanName}, fields...)...)}
}

func (_c *MockObservability_Span_Call) Run(run func(ctx context.Context, spanName string, fields ...zapcore.Field)) *MockObservability_Span_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]zapcore.Field, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(zapcore.Field)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockObservability_Span_Call) Return(_a0 context.Context, _a1 func()) *MockObservability_Span_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockObservability_Span_Call) RunAndReturn(run func(context.Context, string, ...zapcore.Field) (context.Context, func())) *MockObservability_Span_Call {
	_c.Call.Return(run)
	return _c
}

// WithSpanKind provides a mock function with given fields: spanKind
func (_m *MockObservability) WithSpanKind(spanKind trace.SpanKind) *observability.Impl {
	ret := _m.Called(spanKind)

	if len(ret) == 0 {
		panic("no return value specified for WithSpanKind")
	}

	var r0 *observability.Impl
	if rf, ok := ret.Get(0).(func(trace.SpanKind) *observability.Impl); ok {
		r0 = rf(spanKind)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*observability.Impl)
		}
	}

	return r0
}

// MockObservability_WithSpanKind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithSpanKind'
type MockObservability_WithSpanKind_Call struct {
	*mock.Call
}

// WithSpanKind is a helper method to define mock.On call
//   - spanKind trace.SpanKind
func (_e *MockObservability_Expecter) WithSpanKind(spanKind interface{}) *MockObservability_WithSpanKind_Call {
	return &MockObservability_WithSpanKind_Call{Call: _e.mock.On("WithSpanKind", spanKind)}
}

func (_c *MockObservability_WithSpanKind_Call) Run(run func(spanKind trace.SpanKind)) *MockObservability_WithSpanKind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(trace.SpanKind))
	})
	return _c
}

func (_c *MockObservability_WithSpanKind_Call) Return(_a0 *observability.Impl) *MockObservability_WithSpanKind_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockObservability_WithSpanKind_Call) RunAndReturn(run func(trace.SpanKind) *observability.Impl) *MockObservability_WithSpanKind_Call {
	_c.Call.Return(run)
	return _c
}

// meterProvider provides a mock function with no fields
func (_m *MockObservability) meterProvider() {
	_m.Called()
}

// MockObservability_meterProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'meterProvider'
type MockObservability_meterProvider_Call struct {
	*mock.Call
}

// meterProvider is a helper method to define mock.On call
func (_e *MockObservability_Expecter) meterProvider() *MockObservability_meterProvider_Call {
	return &MockObservability_meterProvider_Call{Call: _e.mock.On("meterProvider")}
}

func (_c *MockObservability_meterProvider_Call) Run(run func()) *MockObservability_meterProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockObservability_meterProvider_Call) Return() *MockObservability_meterProvider_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockObservability_meterProvider_Call) RunAndReturn(run func()) *MockObservability_meterProvider_Call {
	_c.Run(run)
	return _c
}

// NewMockObservability creates a new instance of MockObservability. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockObservability(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockObservability {
	mock := &MockObservability{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
